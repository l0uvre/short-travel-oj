/***
Description:
As you know, a cell cycle is start from one end phase to next end phase of Mitosis (or Amitosis). Similarly, letâ€™s define a string cycle. Let T be a substring of S, and S can be generated by T. That means if we append T to T for several times, S will become a substring of T. The string cycle of string S is the smallest length of such T. Now give you a string, please find the string cycle of S.

Input:
The first line will be an integer T, which is the number of test cases. (1 <= T <= 10)

For each test case, there will be an integer n in the first line, which is the length of the string.

And then there will be a line with a string S. |S| <= 1000000

S will only contain lower case English letters.


Output:
Print an integer for each test case which is the string cycle of S.

Input Example:
1
6
abcabc

Output Example:
3

***/


#include<bits/stdc++.h>
using namespace std;

void computeNextArray(string pat, int nt[])
{
    nt[0] = -1;
    int j = 0;
    int k = -1;
    int ptnLen = (int)pat.length();
    while(j < ptnLen - 1)
    {
      if( k == -1 || pat[j] == pat[k])
      {
        nt[++j] = ++k;
      }
      else
      {
        k = nt[k];
      }
    }

}

int main()
{
    int t_times;
    int ptnLen;
    string pattern;
    std::cin.tie(0);
    std::cin >> t_times;
    for (int i = 0; i < t_times; i++)
    {
      std::cin >> ptnLen;
      std::cin >> pattern;
      pattern.push_back('A');

      int nt[ptnLen + 1];
      computeNextArray(pattern, nt);
      int m = ptnLen;
      int j = nt[m];
      int k = m - j;

      pattern.pop_back();
      std::cout<< k << '\n';

    }
}
